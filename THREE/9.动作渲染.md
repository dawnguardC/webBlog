动作渲染
===
###原理
对于Three.js 程序而言，动作渲染的实现是通过在秒中多次重绘画面实现的。FPS（Frames Per Second）指每秒画面重绘的次数。FPS 越大，则渲染效果越平滑，当 FPS 小于 20 时，一般就能明显感受到画面的卡滞现象。当 FPS 足够大（比如达到 60），再增加帧数人眼也不会感受到明显的变化，反而相应地就要消耗更多资源。

**setInterval 方法**
如果要设置特定的 FPS，可以使用该方法：

    setInterval(func, msec)
其中， func 是每过 msec 毫秒执行的函数，如果将 func 定义为重绘画面的函数，就能实现动画效果。

    var id = setInterval(draw, 20);
    function draw() {
        mesh.rotation.y = (mesh.rotation.y + 0.01) % (Math.PI * 2);
        renderer.render(scene, camera);
    }
这样，每 20 毫秒就会调用一次 draw 函数，改变长方体的旋转值，然后进行重绘。最终得到的效果就是 FPS 为 50 的旋转长方体。

**requestAnimationFrame 方法**
不在意多久重绘一次，就适合用 `requestAnimationFrame` 方法。它告诉浏览器在合适的时候调用指定函数，通常可能达到 60FPS。`requestAnimationFrame` 同样有对应的 `cancelAnimationFrame` 取消动画，使用方法类似`clearInterval`。
由于 requestAnimationFrame 只请求一帧画面，与settimeout很相似。因此，除了在init 函数中需要调用，在被其调用的函数中需要再次调用 requestAnimationFrame ：

    function draw() {
        mesh.rotation.y = (mesh.rotation.y + 0.01) % (Math.PI * 2);
        renderer.render(scene, camera);
        var id = requestAnimationFrame(draw);
    }

可以使用`renderer.setAnimationLoop(callback)`来代替`requestAnimationFrame()`。.callback 为每个可用帧都会调用的函数。 如果传入‘null’,所有正在进行的动画都会停止。对于WebVR项目，必须使用此函数。
