点击交互
===
###原理
浏览器是一个2D视口，在里面显示threejs的内容是3D场景，从浏览器观测3D场景时，眼睛就相当于是threejs内的摄像机点，鼠标在屏幕的点击位置是另一个点。这两个点会在threejs内连接成一条直线`raycaster`，直线穿过的threejs内的物体就是鼠标所点击的物体。

###实现
```
 Raycaster( origin : Vector3, direction : Vector3, near : Float, far : Float ) 
```
origin —— 光线投射的原点向量。
direction —— 向射线提供方向的方向向量，应当被标准化。
near —— 返回的所有结果比near远。near不能为负值，其默认值为0。
far —— 返回的所有结果都比far近。far不能小于near，其默认值为Infinity（正无穷）。

**方法**
```
.setFromCamera ( coords : Vector2, camera : Camera ) : null
```
coords —— 在标准化设备坐标中鼠标的二维坐标 。
camera —— 射线所来源的摄像机。

使用一个新的原点和方向来更新射线。

```
.intersectObjects ( objects : Array, recursive : Boolean, optionalTarget : Array ) : Array
```
objects —— 检测和射线相交的一组物体。
recursive —— 若为true，则同时也会检测所有物体的后代。否则将只会检测对象本身的相交部分。默认值为false。
optionalTarget —— （可选）（可选）设置结果的目标数组。如果不设置这个值，则一个新的Array会被实例化；如果设置了这个值，则在每次调用之前必须清空这个数组（例如：array.length = 0;）。

检测所有在射线与这些物体之间，包括或不包括后代的相交部分。返回结果时，相交部分将按距离进行排序，最近的位于第一个），相交部分返回一个包含有交叉部分的数组:

```
[ { distance, point, face, faceIndex, object }, ... ]
```
distance —— 射线投射原点和相交部分之间的距离。
point —— 相交部分的点（世界坐标）
face —— 相交的面
faceIndex —— 相交的面的索引
object —— 相交的物体
uv —— 相交部分的点的UV坐标。

当计算这条射线是否和物体相交的时候，Raycaster将传入的对象委托给raycast方法。 这将可以让mesh对于光线投射的响应不同于lines和pointclouds。

**注意**：对于网格来说，面必须朝向射线的原点，以便其能够被检测到。 用于交互的射线穿过面的背侧时，将不会被检测到。如果需要对物体中面的两侧进行光线投射， 需要将material中的side属性设置为THREE.DoubleSide。


```
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();

function onMouseMove( event ) {

	// 将鼠标位置归一化为设备坐标。x 和 y 方向的取值范围是 (-1 to +1)

	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

}

function render() {

	// 通过摄像机和鼠标位置更新射线
	raycaster.setFromCamera( mouse, camera );

	// 计算物体和射线的焦点
	var intersects = raycaster.intersectObjects( scene.children );

	for ( var i = 0; i < intersects.length; i++ ) {

		intersects[ i ].object.material.color.set( 0xff0000 );

	}

	renderer.render( scene, camera );

}

window.addEventListener( 'mousemove', onMouseMove, false );

window.requestAnimationFrame(render);
```