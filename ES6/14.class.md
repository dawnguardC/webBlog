class
===================
ES5中，生成实例对象的传统方法是通过构造函数,跟传统的面向对象语言（比如 C++ 和 Java）差异很大。
```
function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function () {
  return '(' + this.x + ', ' + this.y + ')';
};
```
ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

```
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }

  toString() {
    return '(' + this.x + ', ' + this.y + ')';
  }
}
```
`constructor`方法就是构造方法，this关键字指向实例对象。需要注意，**方法之间不要逗号分隔**，加了会报错。
**.constructor 方法**
constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。
**类的实例**
生成类的实例，也是直接对类使用new命令，跟构造函数的用法完全一致。
```
class Point {
  // ...
}
var point = new Point();
```
可以通过实例的__proto__属性为“类”添加属性/方法，ES6更推荐使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。注意：类的所有实例共享一个原型对象，**使用实例的__proto__属性改写原型，会改变“类”的原始定义，影响到所有实例**。

**取值函数（getter）和存值函数（setter）**
在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，设定该属性的存取行为。
```
class MyClass {
  constructor() {
    // ...
  }
  get x() {
    console.log('getter');
  }
  set x(value) {
    console.log('setter: '+value);
  }
}

let inst = new MyClass();
inst.prop = 123;
// setter: 123
inst.prop
// 'getter'
```
getter不能有参数，setter有一个参数。
**注意点**
1.不存在提升
2.this 的指向
类的方法内部如果含有this，它默认指向类的实例。但是，在方法中使用this，并将这个方法提取出来单独使用，就会出现错误。一个比较简单的解决方法是在构造方法中绑定this。
```
class Logger {
  constructor() {
    this.printName = this.printName.bind(this);
  }

  // ...
}
```
另一种解决方法是使用箭头函数来写方法。

###类的继承
Class 可以通过extends关键字实现继承。
```
class Point {
}

class ColorPoint extends Point {
}
```
ColorPoint类通过extends关键字，继承了Point类的所有属性和方法。由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，给ColorPoint内部加上代码。
```
class ColorPoint extends Point {
  constructor(x, y, color) {
    super(x, y); // 调用父类的constructor(x, y)
    this.color = color;
  }

  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```
子类必须在constructor方法中调用**super**方法，它表示父类的构造函数，用来新建子类的this对象。

**Object.getPrototypeOf()**
Object.getPrototypeOf方法可以用来从子类上获取父类。可以使用这个方法判断，一个类是否继承了另一个类。

**super 关键字**
super这个关键字，既可以当作函数使用，也可以当作对象使用。
super作为函数调用时，代表父类的构造函数：
```
class A {}

class B extends A {
  constructor() {
    super();
  }
}
```
注意，super虽然代表了父类A的构造函数，但是super内部的this指的是B的实例。而且只能用在子类的构造函数之中，用在其他地方就会报错。
super作为对象时，指向**父类的原型对象**：
```
class A {
  p() {
    return 2;
  }
}

class B extends A {
  constructor() {
    super();
    console.log(super.p()); // 2
  }
}

let b = new B();
```
需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。另外方法内部的this指向当前的子类实例。
```
class A {
  constructor() {
    this.x = 1;
  }
}

class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}

var b=new B()
```