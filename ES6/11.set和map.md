set和map
===
###  set
 Set结构类似于数组，但是成员的值都是**唯一的**，会去除重复的值。Set函数可以接受一个数组（或类数组）作为参数，用来初始化。
```
 const s = new Set([1, 2, 3, 4, 4]);  //Set(4) {1, 2, 3, 4}
```

**属性和方法**

`Set.prototype.size`
返回Set实例的成员总数。

`Set.prototype.add(value)`
添加某个值，返回 Set 结构本身。
`Set.prototype.delete(value)`
删除某个值，返回一个布尔值，表示删除是否成功。
`Set.prototype.has(value)`
返回一个布尔值，表示该值是否为Set的成员。
`Set.prototype.clear()`
清除所有成员，没有返回值。

`Array.from()`
将 Set 结构转为数组
```
const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);
```
由于Set 结构不会添加重复的值，可以用来去除数组重复的成员：
```
let arr = [0,0,0];
let setArr = new Set(arr);
Array.from(setArr); //[0]
```
去除字符串重复的值：
```
let str = 'asdasd';
let setStr = new Set(str);
Array.from(setStr).join('');  //'asd'
```

###  WeakSet
WeakSet 结构与 Set 类似，也是不重复的值的集合。它与 Set 有两个区别：
1. WeakSet 只接收引用类型和 Symbol
2. WeakSet 中的成员都是弱引用，如果这个对象没有被其他地方引用，那么这个对象就会被垃圾回收，它在 WeakSet 里面的引用就会自动消失。

WeakSet 的参数如果是数组（类数组）时，会将数组的每一项分别添加为成员:
```
const a = [[1, 1], [1, 1]];
const ws = new WeakSet(a);
// WeakSet {[1, 1], [1, 1]}
```
因此，如果数组某一项为基本类型，会报错：
```
const b = [1];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
```

WeakSet 结构有以下三个方法：

1. WeakSet.prototype.add(value)：向 WeakSet 实例添加一个新成员，返回 WeakSet 结构本身。
2. WeakSet.prototype.delete(value)：清除 WeakSet 实例的指定成员，清除成功返回true，如果在 WeakSet 中找不到该成员或该成员不是对象，返回false。
3. WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

WeakSet 的成员都是弱引用，随时可能被回收，所以**不能遍历**和清空。

###  map
Map 数据结构类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。
```
let map = new Map();
let obj = {a:1};
map.set(obj,'object');  //Map(1) {{…} => "object"}
```
对同一个键多次赋值，后面的值将覆盖前面的值。注意，只有对同一个对象的引用，Map 结构才将其视为同一个键:
```
let map = new Map();
map.set([1],1);
map.set([1],2);
console.log(map)  //Map(2) {Array(1) => 1, Array(1) => 2}
```
如上，实际上这是两个不同的数组实例，内存地址是不一样的。

Map函数可以接受一个数组（或类数组）作为参数，用来初始化，但这个数组的每一项，都需要是一个个表示键值对的数组。
```
let a = ['1',1];
let b = ['2',2 ]
let map = new Map([ a, b ]);
```

**属性和方法**

1.`size` 属性
size属性返回 Map 结构的成员总数。
2. `Map.prototype.set(key, value)`
set方法设置键名key对应的键值为value，然后返回整个 Map 结构。
3. `Map.prototype.get(key)`
get方法读取key对应的键值，如果找不到key，返回undefined。
4. `Map.prototype.has(key)`
has方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。
5. `Map.prototype.delete(key)`
delete方法删除某个键，返回true。如果删除失败，返回false。
6.` Map.prototype.clear()`
clear方法清除所有成员，没有返回值。

**遍历方法** 

1. `Map.prototype.keys()`  返回键名的遍历器。
2. `Map.prototype.values()`  返回键值的遍历器。
3. `Map.prototype.entries()`  返回所有成员的遍历器。
4. `Map.prototype.forEach()`  遍历 Map 的所有成员。

Map 会保留键值对的插入顺序，遍历顺序就是插入顺序。

###  WeakMap
和Map类似，但WeakMap只接受对象（null除外）和 Symbol 值作为键名，不接受其他类型的值作为键名。其次，WeakMap的键名所指向的对象是弱引用。注意，只有键名是弱引用，键值依然是强引用：
```
let wm = new WeakMap();
let key = ['key'];
let value = ['value'];
wm.set(key, value);

value = null;
wm.get(key) // ['value']

key = null;
wm.get(key) // undefined
```

WeakMap常用于为对象附加私有 / 临时数据，比如Vue内部建立组件实例数据和观测该数据变化时调用的函数之间的关联状态。