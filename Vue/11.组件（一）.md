组件
===================
组件是可复用的 Vue 实例，组件必须在注册之后，再使用。

###  全局组件
注册一个全局组件语法格式如下：

    Vue.component("tagName", options)
tagName 为自定义组件名，为了避免和未来html新标签重复，所以一般将组件名设置为a-b的形式。options 为配置选项对象。
全局注册的组件，可以直接用在任何地方。

    <div id="components-demo">
      <button-counter></button-counter>
      <button-counter></button-counter>
    </div>
    
    
    // 定义一个名为 button-counter 的新组件
    Vue.component('button-counter', {
      data: function () {
        return {
          count: 0
        }
      },
      //模版只能有一个根节点，只能获取组件自己data的数据
      template: '<button v-on:click="count++">You clicked me {{ count }} times.</button>'
    })
    // 创建根实例
    new Vue({ el: '#components-demo' })
**一个组件的 data 选项必须是一个函数**，函数返回一个新的对象，这样每个实例才会有自己的独立数据，这些实例之间才不会产生干扰。

###  局部组件
先使用对象来定义组件配置：
```
var ComponentA = { /* ... */ }
var ComponentB = { /* ... */ }
```
再在需要的地方注册：
```
new Vue({
  el: '#app',
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})
```
注意：使用局部注册的组件，必须先在实例中注册，否则不可用。

局部组件的优点在于，使用打包工具时，全局组件不论是否使用，都会被打包，而局部组件只有使用了，才会打包。

**模板**
组件的template内容可以抽离出来，放在template标签内，通过template的id引入组件内：
```
//html内
<template id="example">
  <div>
  ...
  </div>
</template>
  
  //组件内
  template: '#example'
```
同样，template标签内，**只能有一个根元素**。

###  组件非prop的 Attribute
组件的attr属性除了prop（接收父元素数据）以外，其他的默认都会传递到组件的根元素上。这其中，class和style会和根元素的attr叠加，其他的会进行覆盖。
要禁止组件的根元素继承 attribute，可以在组件的选项中设置 inheritAttrs: false。
```
Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
```
**$attrs**

根元素内的其他元素可能需要组件的attr，给这个元素添加 v-bind="$attrs" 就能获取组建的所有非prop的attr。
```
<template id="myComp">
    <div>
        <input v-bind="$attrs">
    </div>
</template>

<my-comp type="text"></my-comp> //<input type="text">
<my-comp type="password"></my-comp> //<input type="password">
```
这个规则也适用于事件监听器，所以，推荐将事件绑定在组件实例中，不写在组件模版内。

###  组件的v-model

```
<my-input v-model="text"></my-input>
```
以 input[type="text"] 为例，组件 v-model 实际
为 :value 和 @input :
```
<my-input :value="text" @input="input"></my-input>
```
因此，组件模板内，需要props传递value给input元素，并且input元素的input事件需要$emit一个自定义input事件给组件。
```
Vue.component('my-input', {
  props: ['value'],
  template: `
    <input :value="value" @input="$emit('input', $event.target.value)">
  `
})
```

v-model这个语法糖在input、radio等有不同的实现，在组件上就默认使用value和input。则对于模版有radio这种的，就不太合适，需要model 选项来更改默认内容。

###  插槽slot
组件元素之间的位置我称之为插槽位，内容本来是没有作用的：
```
<my-component></my-component>

<my-component>无效的数据</my-component>
```
正常来说，渲染结果一样。但是如果my-component组件模版内使用solt元素，则插槽位的内容会替换solt元素。solt就称为插槽。
```
template: `
  <div>
    <slot></slot>
  </div>
`
```  
组件在复用时，插槽位的内容不同，实际的渲染结果就不同。使用插槽的组件有了差异性，变得很灵活：
```
<div id="app">
  <my-panel>111</my-panel>   //111
  <my-panel>222</my-panel>   //222
</div>

<template id="example">
  <div>
  <slot></slot>
  </div>
</template>

Vue.component('my-panel',{
  template:'#example'
})
new Vue({
  el:'#app'
})
```

插槽位和组件具有相同的作用域,无法直接访问子组件的数据。

**默认值**
slot标签可以设置默认值，如果插槽位没有数据，就渲染默认值：
```
<slot>默认值</slot>
```

###  具名插槽
slot具有name属性，只有name相同的插槽位才能对应替换slot：
```
<div id="app">
  <my-panel>
    <template slot="first">111</template>
    <template slot="second">222</template>
  </my-panel>
</div>

<template id="example">
  <div>
    <div><slot name='first'></slot></div>
    <div><slot name='second'></slot></div>
  </div>
</template>
```
一个不带 name 的slot带有隐含的名字“default”。

**vue2.6+及vue3中则使用v-slot:name代替slot='name'**：
```
<my-panel>
  <template v-slot:first>
    <p>111</p>
  </template>
  <template v-slot:second>
    <p>222</p>
  </template>  
</my-panel>  
```
**v-slot只能写在template上**，所以插槽位元素都需要放置于template标签内。

`v-slot:name`可以缩写为`#name`。

###  作用域插槽
有时要用插槽位来展示组件的数据，就需要组件在slot标签内使用属性绑定数据data,再在实例中，插槽位使用`slot-scope="data"`来获取数据。vue2.6+及vue3使用`v-slot`代替`slot-scope`

```
// 组件
<slot :user="user"></slot>

data(){
    return {
        user: {name: '用户名'},
    }
}

// 组件模板
<template v-slot="slotData">
  <p>{{ slotData.user.name }}</p>
</template>
```

具名插槽和作用域插槽可以同时使用：
`#name='slotData'`


