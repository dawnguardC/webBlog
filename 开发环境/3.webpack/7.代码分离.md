代码分离
=== 

多个js文件需要打包到不同的bundle中：
```
entry: {
    index1: './src/index1.js',  //key(index1，index2)会作为打包的name
    index2: './src/index2.js',
},
output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
},
```
这样打包的结果会是index1.bundle.js和index2.bundle.js。这两个js源文件内用到了重复的模块，可以抽离出来到一个单独的chunk中：
```
optimization: {
    splitChunks: {
        chunks: 'all',
        // 自定义拆分规则
        cacheGroups: {
            // 使用的 node_modules 中的依赖
            vendors: {
                test: /[\\/]node_modules[\\/]/, // 匹配 node_modules 下的模块
                name: 'vendors',
                reuseExistingChunk: true // 优先复用 chunk
            },
            // 使用的自己的模块
            common: {
                test: /\.js$/,
                name: 'common',
                reuseExistingChunk: true
            }
        }
    },
},
```
这样会打包为index1.bundle.js，index2.bundle.js，common.bundle.js三个文件。
html页在引用时，就可以：
```
plugins: [
    // HTML配置：引入 vendors + common + index
    new HtmlWebpackPlugin({
        filename: 'index1.html',
        template: './src/index1.html',
        // chunks 包含公共块 + 页面专属块，顺序不能乱（公共在前）
        chunks: ['vendors', 'common', 'index1']
    }),
    new HtmlWebpackPlugin({
        filename: 'index2.html',
        template: './src/index2.html',
        chunks: ['vendors', 'common', 'index2']
    })
]
```

### 动态导入

另外，如果有使用import()函数异步导入的模块，这个模块也会被单独抽离出来。这个异步模块打的包名字可以在引入时使用魔法注释传入。